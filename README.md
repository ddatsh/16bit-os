# 16位 Hello World 内核

一个简单的16位操作系统内核示例，演示了从引导扇区到内核的完整启动过程，使用NASM汇编和C编写，能够打印"Hello World"消息

## 文件结构

- `boot.asm`  引导扇区代码，负责加载内核
- `kernel_entry.asm`  内核入口点，调用C语言内核函数
- `kernel.c`  内核主程序，包含打印功能
- `Makefile`  编译脚本
- `README.md`  说明文档

## 运行环境
wsl 中，确保已安装：
- NASM
- GCC
- Make
- QEMU (用于运行)

```bash
sudo apt update
sudo apt install nasm gcc make qemu-system-x86
```

## 编译和运行

```bash
./run.sh
```


## 工作原理

1. **引导扇区** (`boot.asm`)：
   - BIOS加载到内存地址0x7c00
   - 显示"Loading kernel..."消息
   - 从磁盘读取内核到内存地址0x1000
   - 跳转到内核代码

2. **内核入口** (`kernel_entry.asm`)：
   - 设置段寄存器和栈
   - 调用C语言的内核主函数

3. **内核主程序** (`kernel.c`)：
   - 清屏
   - 打印"Hello World"消息
   - 进入无限循环

## 技术细节

- 使用16位实模式
- 直接操作VGA显存 (0xB8000)
- 白字黑底显示
- 支持换行符处理
- 简单的光标管理

## 扩展建议

- 添加键盘输入处理
- 实现简单的命令解释器
- 添加文件系统支持
- 实现多任务调度
- 添加图形界面支持

## 文件详细说明

### 1. boot.asm - 引导扇区

**功能**: 计算机启动时BIOS首先加载的512字节代码

**关键特性**:
- 使用 `[org 0x7c00]` 设置代码加载地址
- 使用 `[bits 16]` 指定16位模式
- 初始化段寄存器 (DS, ES, SS)
- 设置栈指针 (SP = 0x7c00)

**启动流程**:
1. 显示 "Loading kernel..." 消息
2. 使用BIOS中断0x13读取磁盘扇区
3. 将内核加载到内存地址0x1000
4. 跳转到内核代码

**BIOS调用**:
```assembly
mov ah, 0x02    ; 读取扇区功能
mov al, 1       ; 读取1个扇区
mov ch, 0       ; 柱面0
mov cl, 2       ; 从扇区2开始
mov dh, 0       ; 磁头0
mov dl, 0x80    ; 驱动器0
mov bx, 0x1000  ; 加载地址
int 0x13        ; 调用BIOS中断
```

### 2. kernel_entry.asm - 内核入口点

**功能**: 连接汇编和C代码的桥梁

**关键特性**:
- 声明外部C函数 `kernel_main`
- 设置正确的段寄存器和栈
- 调用C语言内核函数

**代码结构**:
```assembly
[extern kernel_main]    ; 声明外部C函数
global _start           ; 全局入口点

_start:
    mov ax, 0x1000      ; 内核段地址
    mov ds, ax          ; 数据段
    mov es, ax          ; 附加段
    mov ss, ax          ; 栈段
    mov sp, 0x1000      ; 栈指针
    call kernel_main    ; 调用C函数
```

### 3. kernel.c - 内核主程序

**功能**: C语言编写的内核核心功能

**关键特性**:
- 直接操作VGA显存 (地址0xB8000)
- 实现字符显示和光标管理
- 支持换行符处理
- 白字黑底显示效果

**VGA显存结构**:
- 每个字符占用2字节
- 低字节: ASCII字符
- 高字节: 颜色属性 (0x0F = 白字黑底)

**核心函数**:
- `clear_screen()`: 清屏
- `putchar(char c)`: 打印单个字符
- `print_string(const char* str)`: 打印字符串
- `kernel_main()`: 内核主函数

### 4. Makefile - 编译脚本

**功能**: 自动化编译和构建过程

**编译流程**:
1. 编译引导扇区: `nasm -f bin -o boot.bin boot.asm`
2. 编译内核入口: `nasm -f elf32 -o kernel_entry.o kernel_entry.asm`
3. 编译C内核: `gcc -m16 -fno-pie -nostdlib -nostdinc -fno-builtin -fno-pic -march=i386 -O0 -fno-stack-protector -c -o kernel.o kernel.c`
4. 链接内核: `ld -m elf_i386 --oformat binary -Ttext 0x0000 -o kernel.bin`
5. 创建磁盘镜像: 使用dd命令组合文件

**关键编译选项详解**:

**GCC选项**:
- `-m16`: 生成16位代码，使用16位寄存器和寻址模式
- `-fno-pie`: 禁用位置无关可执行文件，生成绝对地址代码
- `-nostdlib`: 不使用标准C库，避免链接外部依赖
- `-nostdinc`: 不使用标准头文件路径，避免包含系统头文件
- `-fno-builtin`: 禁用内置函数，避免GCC优化替换
- `-fno-pic`: 禁用位置无关代码，生成绝对地址
- `-march=i386`: 指定目标架构为Intel 386，确保兼容性
- `-O0`: 禁用所有优化，保持代码的原始结构
- `-fno-stack-protector`: 禁用栈保护，避免额外的安全检查

**NASM选项**:
- `-f bin`: 生成原始二进制文件（用于引导扇区）
- `-f elf32`: 生成ELF32格式目标文件（用于链接）

**LD选项**:
- `-m elf_i386`: 指定目标格式为ELF32
- `--oformat binary`: 输出格式为原始二进制
- `-Ttext 0x0000`: 设置代码段起始地址为0x0000

## 内存布局和地址解析

### 地址映射原理分析

#### 关键代码地址设置

| 文件 | 代码片段 | 寄存器/地址 | 物理地址计算 | 说明 |
|------|----------|-------------|--------------|------|
| boot.asm | `mov bx, 0x1000` | bx = 0x1000 | DS×16 + 0x1000 = 0×16 + 0x1000 = **0x1000** | BIOS读取扇区目标地址 |
| kernel_entry.asm | `mov ax, 0x100` | ax = 0x100 | 段地址设置 | 内核段地址 |
| kernel_entry.asm | `mov sp, 0x1000` | sp = 0x1000 | SS×16 + SP = 0x100×16 + 0x1000 = **0x2000** | 栈指针偏移地址 |

#### 内核加载与执行流程

| 阶段 | 操作 | 段地址 | 偏移地址 | 物理地址 | 说明 |
|------|------|--------|----------|----------|------|
| 引导扇区阶段 | 加载内核 | 0x000 | 0x1000 | 0x1000 | boot.asm将内核加载到物理地址0x1000 |
| 内核执行阶段 | 运行内核 | 0x100 | 0x0000 | 0x1000 | kernel_entry.asm在段0x100:0x0000运行 |
| 栈设置阶段 | 设置栈 | 0x100 | 0x1000 | 0x2000 | 栈从物理地址0x2000开始，向下增长 |

#### 地址关联关系总结

| 组件 | 段地址 | 偏移地址 | 物理地址 | 关键发现 |
|------|--------|----------|----------|----------|
| 内核加载位置 | 0x000 | 0x1000 | 0x1000 | 引导扇区加载目标 |
| 内核运行位置 | 0x100 | 0x0000 | 0x1000 | **与加载位置相同！** |
| 内核栈位置 | 0x100 | 0x1000 | 0x2000 | 避免与代码区域冲突 |

### 16位实模式地址计算原理

#### 地址计算公式

**物理地址 = 段地址 × 16 + 偏移地址**

#### 段寄存器作用

| 段寄存器 | 用途 | 示例 |
|----------|------|------|
| DS (Data Segment) | 数据段 | 数据访问时的默认段 |
| ES (Extra Segment) | 附加段 | 字符串操作时的目标段 |
| SS (Stack Segment) | 栈段 | 栈操作时的段地址 |
| CS (Code Segment) | 代码段 | 指令执行时的段地址 |

#### 地址计算示例

| 段地址 | 偏移地址 | 计算过程 | 物理地址 | 说明 |
|--------|----------|----------|----------|------|
| 0x100 | 0x0000 | 0x100×16 + 0x0000 | 0x1000 | 内核代码段 |
| 0x100 | 0x1000 | 0x100×16 + 0x1000 | 0x2000 | 内核栈段 |
| 0x000 | 0x1000 | 0x000×16 + 0x1000 | 0x1000 | 引导扇区加载地址 |

### 内存布局图表

#### 物理内存地址布局

| 地址范围 | 大小 | 用途 | 说明 |
|----------|------|------|------|
| 0x0000 - 0x0FFF | 4KB | 可用内存 | 系统启动时的可用内存区域 |
| 0x1000 - 0x1FFF | 4KB | 内核代码区域 | • boot.asm加载内核到这里<br>• kernel_entry.asm在段0x100:0x0000运行 |
| 0x2000 - 0x2FFF | 4KB | 栈区域 | • kernel_entry.asm设置sp=0x1000，段0x100<br>• 实际物理地址0x2000，向下增长 |
| 0x3000 - 0x7BFF | 19KB | 可用内存 | 内核和引导扇区之间的可用内存 |
| 0x7C00 - 0x7DFF | 512字节 | 引导扇区 | • BIOS加载到0x7C00<br>• 包含boot.asm代码 |
| 0x7E00 - 0x9FFF | 8.5KB | 可用内存 | 引导扇区后的可用内存 |
| 0xA000 - 0xBFFF | 8KB | 视频内存 | • 文本模式显存<br>• 地址0xB8000开始 |
| 0xC000 - 0xFFFF | 16KB | 可用内存 | 视频内存后的可用内存 |

#### 段地址映射关系

| 段地址 | 偏移地址 | 物理地址 | 说明 |
|--------|----------|----------|------|
| 0x000 | 0x1000 | 0x1000 | boot.asm加载地址 |
| 0x100 | 0x0000 | 0x1000 | kernel_entry.asm代码段 |
| 0x100 | 0x1000 | 0x2000 | kernel_entry.asm栈段 |

#### 关键地址对应关系

| 组件 | 段地址 | 偏移地址 | 物理地址 | 说明 |
|------|--------|----------|----------|------|
| 引导扇区 | 0x000 | 0x7C00 | 0x7C00 | BIOS加载地址 |
| 内核加载 | 0x000 | 0x1000 | 0x1000 | boot.asm加载目标 |
| 内核运行 | 0x100 | 0x0000 | 0x1000 | kernel_entry.asm代码段 |
| 内核栈 | 0x100 | 0x1000 | 0x2000 | kernel_entry.asm栈段 |


## 启动过程详解

1. **BIOS阶段**:
   - 计算机加电
   - BIOS执行POST (Power-On Self Test)
   - BIOS搜索可启动设备
   - 读取第一个扇区到0x7c00

2. **引导扇区阶段**:
   - 执行boot.asm代码
   - 初始化段寄存器
   - 显示加载消息
   - 读取内核到0x1000

3. **内核阶段**:
   - 执行kernel_entry.asm
   - 设置内核环境
   - 调用kernel_main()
   - 显示Hello World消息

## 编译选项详解

### 为什么需要这些编译选项？

**16位代码生成**:
- `-m16`: 强制GCC生成16位代码，使用16位寄存器和寻址模式
- 现代GCC默认生成32位或64位代码，需要明确指定16位模式

**避免现代特性**:
- `-fno-pie`: 禁用位置无关可执行文件，避免地址重定位
- `-fno-pic`: 禁用位置无关代码，生成绝对地址
- `-fno-stack-protector`: 禁用栈保护，避免额外的安全检查代码

**独立编译**:
- `-nostdlib`: 不使用标准C库，避免链接外部依赖
- `-nostdinc`: 不使用标准头文件路径，避免包含系统头文件
- `-fno-builtin`: 禁用内置函数，避免GCC优化替换

**兼容性保证**:
- `-march=i386`: 指定目标架构为Intel 386，确保最大兼容性
- `-O0`: 禁用所有优化，保持代码的原始结构和可预测性

### 编译选项的影响

**代码大小**: 禁用优化和库依赖使代码更小
**兼容性**: 确保在16位实模式下正确运行
**可预测性**: 避免现代编译器特性的干扰
**调试性**: 保持代码结构便于调试

## 技术难点

1. **16位模式限制**:
   - 段寄存器管理
   - 内存寻址限制
   - 栈操作注意事项

2. **VGA显存操作**:
   - 直接内存映射
   - 字符和属性字节
   - 光标位置计算

3. **C和汇编混合**:
   - 调用约定
   - 栈帧管理
   - 段寄存器设置

4. **编译环境配置**:
   - 现代编译器与16位代码的兼容性
   - 链接器地址设置
   - 目标格式选择

## 扩展可能性

1. **键盘输入**:
   - 使用BIOS中断0x16
   - 实现简单的命令解释器

2. **文件系统**:
   - FAT12文件系统支持
   - 文件读写功能

3. **内存管理**:
   - 分页机制
   - 内存分配器

4. **多任务**:
   - 简单的任务切换
   - 时间片轮转

## 调试技巧

1. **使用QEMU调试**:
   ```bash
   qemu-system-i386 -fda os.img -s -S
   ```

2. **GDB调试**:
   ```bash
   gdb -ex "target remote localhost:1234"
   ```

3. **查看内存**:
   ```bash
   hexdump -C os.img | head -20
   ```

## 常见问题

1. **编译错误**: 检查GCC版本和编译选项
   - 确保GCC支持16位编译 (`-m16`)
   - 检查所有必要的编译选项是否完整
   - 某些GCC版本可能不完全支持16位模式

2. **运行错误**: 确保QEMU正确安装
   - 检查QEMU版本兼容性
   - 确保磁盘镜像格式正确

3. **显示问题**: 检查VGA显存地址和属性
   - 确认显存地址0xB8000正确
   - 检查字符和属性字节设置

4. **段错误**: 检查段寄存器设置
   - 确认段寄存器初始化正确
   - 检查内存地址计算

5. **链接错误**: 检查链接器设置
   - 确认 `-Ttext 0x0000` 设置正确
   - 检查目标格式设置

6. **代码不运行**: 检查编译选项
   - 确保没有使用现代编译器特性
   - 检查是否禁用了所有优化
   - 确认没有链接外部库

这个项目为学习操作系统开发提供了良好的基础，可以在此基础上进行更多扩展